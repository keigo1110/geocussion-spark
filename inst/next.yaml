- id: P-PERF-001
  title: "MeshPipeline 差分判定の過敏化による極端な FPS 低下"
  module: ["src/mesh/pipeline.py", "src/mesh/manager.py"]
  severity: "High"
  description: |
    _prev_sample を正しく初期化したことで距離ベースの差分判定が毎フレーム true となり、
    LODMeshGenerator が常にフル再生成を行うようになった。その結果 GPU なし環境で
    120→2 FPS まで低下。
  cause: |
    • ランダムサンプリングがフレーム毎に変わるため平均距離が常に閾値 0.01m を超過。
    • Jaccard voxelHash や pointCountRatio を EWMA 集約せず raw 判定している。
  fix_suggestion: |
    1) サンプル点インデックスを初回生成後に固定 (np.random.default_rng(seed).choice)。
    2) _DIFF_THRESHOLD_M を 0.03m に緩和し、距離 metric = median とする。
    3) voxelHash & countRatio を EWMA(alpha=0.3) で平滑化し、スコア >0.6 で dirty。
    4) 前回 LOD 生成後 200ms 未満なら強制キャッシュヒット (regeneration debounce)。
  related_tasks: [T-MESH-202]
  status: "TODO"

- id: T-PERF-001
  description: "MeshPipeline 差分ヒューリスティック最適化 & デバウンス"
  depends_on: [P-PERF-001]
  steps:
    - "1. 固定 RNG でサンプリング ID を初期化 (_rng = np.random.default_rng(1234))。"
    - "2. _distance_based_change: median(|p_i - prev_i|) > threshold 判定。"
    - "3. EWMA スコア計算 util を src/mesh/utils.py に実装し diff メトリクスへ適用。"
    - "4. PipelineManager.update_if_needed で 前回 regenerate からの経過時間を見て最小 0.2s 間隔を保証。"
  acceptance_criteria:
    - "手無しシーンで FPS ≥100、手移動時 regenerate で 30–60 FPS を維持。"
  status: "TODO"

- id: P-PERF-002
  title: "CPU Delaunay 100k+ pts がメインスレッドをブロックし GUI タイムアウト"
  module: ["src/mesh/pipeline.py", "src/mesh/lod_mesh.py", "src/mesh/delaunay.py"]
  severity: "Critical"
  description: |
    LODMeshGenerator が高密度点群 (≒70k~100k points) をそのまま CPU DelaunayTriangulator
    に渡し、30ms 以上ブロック。Open3D/UI のイベントポンプが遅れ "強制終了" 扱いで
    ターミナル SIGINT が送出される（ユーザが強制終了と誤解）。
  fix_suggestion: |
    • LODMeshGenerator.generate_mesh 内で adaptive_sampling=True の場合、
      max_points を 12,000 に制限し八分木 subsample を行う。
    • MeshPipeline.generate_mesh で CPU fallback 検知時 (triangulator.use_gpu=False)
      に sampling_ratio=0.15 を強制し再実行。
    • Triangulator を background ThreadPoolExecutor.submit() で非同期化し、
      進行中は cached_mesh を返して UI がフリーズしないようにする。
  status: "TODO"

- id: T-PERF-002
  description: "LODMeshGenerator adaptive_sampling + 非同期三角分割"
  depends_on: [P-PERF-002]
  steps:
    - "1. lod_mesh.py: max_points 引数を追加し default=12000。pointcloud が多い場合 subsample。"
    - "2. delaunay.py: triangulate_heightmap_async(height_map) を実装 (ThreadPoolExecutor)。"
    - "3. MeshPipeline.generate_mesh: GPU なし & points>max ⇒ async call, 旧 mesh を返却。"
    - "4. PipelineManager.update_if_needed: async future 完了時に結果を swap-in。"
  acceptance_criteria:
    - "常時 GUI 応答あり (Open3D 10 FPS 以上)。"
    - "手動 SIGINT なしで 3 分連続動作確認。"
  status: "TODO"

- id: P-HAND-001
  title: "手ポイントが地形メッシュに混入する (手検出中のメッシュ更新)"
  module: ["src/mesh/pipeline.py", "src/mesh/lod_mesh.py", "src/mesh/manager.py", "src/input/pointcloud.py"]
  severity: "Medium"
  description: |
    手が画面内に映っているフレームで MeshPipeline がメッシュを更新すると、
    手の点群も地形ポイントとして扱われ、メッシュ上に "地形に埋まった手" の
    スパイクが生成される。結果として衝突判定が誤反応し、手が地形とみなされる。
  cause: |
    • 手領域を除去するマスク処理が未実装。
    • PipelineManager が "手検出中は更新しない" ガードを持たない。
  fix_suggestion: |
    1) HandMasker: hands3d 投影後の 3D 位置から KDTree 半径検索で周辺(±3cm)の点を除外。
    2) Mesh update gating: PipelineManager.update_if_needed() で tracked_hands が存在
       かつ velocity<0.05m/s のときは regenerate を延期 (max 0.5s)。
    3) PointCloudConverter に hand_mask argument を追加し深度→点群変換時に除外。
  status: "TODO"

- id: T-HAND-001
  description: "Hand mask & update gating 実装"
  depends_on: [P-HAND-001]
  steps:
    - "1. src/input/pointcloud.py: mask_points(points, centers, radius) を実装。"
    - "2. FullPipelineViewer._generate_point_cloud_if_needed で HandMasker を呼び出し。"
    - "3. PipelineManager.update_if_needed: tracked_hands がある場合 dirty スコアを半減し、\n      force_update フラグを無視するオプションを追加。"
  acceptance_criteria:
    - "手が映った状態でメッシュ更新しても手形状が地形に含まれない。"
    - "手が退いた後 0.3s 以内に地形メッシュが更新される。"
  status: "TODO"

- id: P-INPUT-002
  title: "カメラインスタンス未準備時の深度/点群ハンドリングでフリーズ"
  module: ["demo_collision_detection.py", "src/input/pointcloud.py", "src/input/mock_camera.py"]
  severity: "High"
  description: |
    カメラが初期化されていない、または depth_intrinsics が None の状態でも
    フレーム処理が進み、PointCloudConverter に None が渡って AttributeError
    (height 参照) でフリーズする。ヘッドレスモード／モックカメラ使用時に再現。
  cause: |
    • _get_frame_data() が None を返した後でも表示処理が続行されるパスが存在。
    • PointCloudConverter 初期化時に depth_intrinsics None チェックが不足。
  fix_suggestion: |
    1) demo_collision_detection.py の _get_frame_data() が None を返す場合はフレームスキップ。
    2) PointCloudConverter.__init__ で depth_intrinsics が None の場合はモック Intrinsics
       (424x240, fx=fy=1, cx=cy=0) を自動生成し、安全に動作させる。
    3) MockCamera.get_frame() が depth_intrinsics を返すプロパティを追加し Viewer が参照可能にする。
  status: "TODO"

- id: T-INPUT-002
  description: "カメラ未接続パスの Null セーフ化 & モックカメラ改良"
  depends_on: [P-INPUT-002]
  steps:
    - "1. PointCloudConverter.__init__ に depth_intrinsics None → create_default_intrinsics() を追加。"
    - "2. demo_collision_detection._get_frame_data() で None フレームは安全にスキップ。"
    - "3. src/input/mock_camera.py に depth_intrinsics プロパティと FrameData 型を実装。"
  acceptance_criteria:
    - "カメラ未接続・ヘッドレスでもフリーズせず 100 フレーム連続処理が可能。"
  status: "TODO"

- id: P-HAND-002
  title: "手メッシュ混入が残存 (HandMask 半径不足 & 投影誤差)"
  module: ["src/input/pointcloud.py", "src/mesh/manager.py", "src/detection/hands3d.py"]
  severity: "Medium"
  description: |
    手周辺 3cm マスクでは指先・高速移動時の残像ポイントを除去しきれず、
    依然として地形メッシュに突起が残る。手検出の投影誤差や MediaPipe の
    遅延により手中心がずれているケースで混入が発生。
  cause: |
    • 手ランドマークの 3D 投影誤差 (±1.5cm) で中心マスクから漏れる。
    • Depth temporal smoothing により過去フレームの手点が残存。 
  fix_suggestion: |
    1) Adaptive radius: finger reach を考慮し velocity に応じて 3–6cm に拡大。
    2) Depth image domain mask: 2D 手バウンディングボックスを膨張 (×1.3) し、
       DepthToPointCloud 前に depth[pixels_in_bbox] = 0 で確実に除去。
    3) Rolling background: MeshPipeline regenerate 時のみ直近5フレーム AND マスク適用
       の合成 depth を使用し残留手点を平均化。
    4) 手検出が無いフレームでのみ background accumulation。 
  status: "TODO"

- id: T-HAND-002
  description: "Adaptive HandMask + Depth-domain blanking 実装"
  depends_on: [P-HAND-002]
  steps:
    - "1. HandMasker クラスを src/detection/hand_mask.py に新規実装 (2D bbox, depth blank)。"
    - "2. PointCloudConverter.numpy_to_pointcloud 内で depth_array に直接ブランキング処理を挿入。"
    - "3. exclude_radius = max(0.03, velocity*0.5) で動的半径を計算。"
    - "4. PipelineManager.update_if_needed() で background accumulation (deque maxlen=5) を実装。"
  acceptance_criteria:
    - "手が映っている間、地形メッシュに手の突起が一切含まれない (100 フレーム連続テスト)。"
    - "手がフレームアウト後 0.3s 以内にメッシュが正常更新。"
  status: "TODO"

- id: P-HAND-003
  title: "手検出中はメッシュ更新を抑制し突起混入を根本回避"
  module: ["src/mesh/manager.py", "demo_collision_detection.py"]
  severity: "Low"
  description: |
    マスク処理で大半の手点は除去できたが、マスク半径が過剰に大きい場合に
    地形が欠損し FPS が低下するケースがある。また残像で稀に突起が残る。
    手がフレーム内に存在する限りメッシュ再生成を延期するポリシーを組み合わせることで
    一切の混入を防ぎつつ処理負荷も低減できる。
  fix_suggestion: |
    • PipelineManager.update_if_needed(): tracked_hands が存在したら dirty スコアを 0.0 とし
      regenerate をスキップ（最長 0.5s）。
    • 手がフレームアウトした瞬間に force_regenerate フラグを立て、即時再計算。
  status: "TODO"

- id: T-HAND-003
  description: "Hand presence gating 実装"
  depends_on: [P-HAND-003]
  steps:
    - "1. src/mesh/manager.py: hands が存在する場合は _pending_hands フラグを立て regenerate を延期。"
    - "2. 同フラグ解除時 (hands==[]) に MeshPipeline.generate_mesh(force_update=True) を即実行。"
    - "3. demo_collision_detection.py: hand list変化を監視し PipelineManager に通知。"
  acceptance_criteria:
    - "手がフレーム内にある間はメッシュが更新されず FPS 優先。"
    - "手が消えた 0.3s 以内にメッシュが更新し突起ゼロ。"
  status: "TODO"

- id: P-INPUT-003
  title: "depth_intrinsics None で PointCloud display error 再発"
  module: ["demo_collision_detection.py", "src/input/pointcloud.py"]
  severity: "Medium"
  description: |
    ログに "Camera or depth intrinsics not available" → display error 'NoneType' object has no attribute 'height'.
    display パスで _extract_depth_image が camera.depth_intrinsics None を検出しつつ後段で reshape を試みる。
  fix_suggestion: |
    • demo_collision_detection._extract_depth_image(): intrinsics None ならデフォルト intrinsics 生成ロジックを再利用。
    • または MockCamera, OrbbecCamera の depth_intrinsics を必ず non-None に保証。
  status: "TODO"

- id: T-INPUT-003
  description: "Depth intrinsics NULL safety in display pipeline"
  depends_on: [P-INPUT-003]
  steps:
    - "1. MockCamera.depth_intrinsics が None を返さないことを再確認 (既対応)。"
    - "2. demo_collision_detection._extract_depth_image で fallback_intrinsics = _create_default_intrinsics() を使用。"
  acceptance_criteria:
    - "このログが 100 フレーム実行で一切出現しない。"
  status: "TODO"
